\documentclass{../preamble}

% Title information
\date{11.01.2021 - 15.01.2021}
\sheetnumber{6}
\version{28. Dezember 2020}

% Document
\begin{document}

\maketitle

\makedisclaimer

\clearpage

\begin{task}[credit = \stars{0}{3}]{Theoriefragen}
    Erklären Sie kurz in eigenen Worten die folgenden Konzepte:
    \begin{enumerate}
        \item Was sind Funktionen höherer Ordnung? Wo liegen ihre Vorteile?
        \item Was ist ein Lambda-Ausdruck?
        \item Wieso sollte man Abstraktion beim Programmieren verwenden?
    \end{enumerate}

    \begin{solution}
        \begin{enumerate}
            \item Funktionen höherer Ordnung sind Funktionen, die als Parameter eine Funktion erhalten und oder eine Funktion als Rückgabewert haben. Ihre Vorteile liegen darin, dass sie ihre eigene Funktion anhand des Parameters anpassen (größere Abstraktion) oder Funktionen anhand bestimmter Parameter erstellen können. Durch die Abstraktion ergibt sich eine breitere Verwendungsmöglichkeit, d.h. eine Anpassbarkeit an eine Vielzahl gleichartiger Aufgaben.
            \item Lambda-Ausdrücke sind Literale von Funktionstypen und haben daher, wie Literale anderer Typen erst einmal keinen Namen (anonyme Funktion), solange man sie nicht einer Variablen/Konstanten zuweist.
                  \br
                  In Bezug auf Java kann man sich einen Lambda-Ausdruck folgendermaßen vorstellen: Ein Lambda-Ausdruck ist eine anonyme Funktion, welche nur durch Referenzen und Verweise angesprochen werden kann, aber nicht über einen Bezeichner.
            \item Durch das Unterteilen in Unterklassen und Methoden muss bei gleichartigen Aufgaben nicht bei jeder dieser Aufgabe alles von Grund auf neu programmiert werden, sondern es wird das Gemeinsame in eine einzige Entität (Klasse, Interface oder Methode in Java; Funktion in Racket) heraus faktorisiert. Es müssen also nur noch die spezifischen Aspekte bei jeder Aufgabe implementiert werden. Das umfasst dann auch zusätzlich Aufgaben von einem ähnlichen Typ, die heute noch gar nicht bekannt sind. Der Hauptvorteil ist, dass man Wiederholungen vermeidet, was nicht nur aufwändig, sondern auch fehleranfällig ist. Ein weiterer Vorteil ist, dass man mit etwas Übung in abstraktem Denken einen solchen Code besser versteht und ihn daher auch besser weiter pflegen kann.
        \end{enumerate}
    \end{solution}
\end{task}

\begin{task}[credit = \stars{1}{3}]{Ausdrücke mit Funktionen höherer Ordnung}
    In der Vorlesung haben Sie die Funktionen \code{my-map}, \code{my-filter} und \code{my-fold} kennengelernt und diese selbst implementiert. Alle drei Funktionen gibt es mit identischer Funktionalität bereits vordefiniert in DrRacket und haben die Namen
    \textcolor{keywordcolor}{map}, \textcolor{keywordcolor}{filter} und \textcolor{keywordcolor}{foldr}.
    \br
    Was liefern die folgenden Ausdrücke zurück? Arbeiten Sie hier ausschließlich mit Stift und Papier und verwenden Sie DrRacket erst hinterher, nur zur Überprüfung Ihrer Ergebnisse.
    \begin{enumerate}
        \item (\textcolor{keywordcolor}{map} + (\textcolor{keywordcolor}{list} 1 2 3)(\textcolor{keywordcolor}{list} 4 5 6))
        \item (\textcolor{keywordcolor}{filter} \textcolor{keywordcolor}{positive?} (\textcolor{keywordcolor}{list} 1 -2 3 4 -5))
        \item (\textcolor{keywordcolor}{foldr} + 0 (\textcolor{keywordcolor}{list} 5 -9 3 2 5 6))
        \item (\textcolor{keywordcolor}{filter} \textcolor{keywordcolor}{string?} (\textcolor{keywordcolor}{list} 1 2 \grqq 3\grqq{} \grqq 4\grqq))
        \item (\textcolor{keywordcolor}{first} (\textcolor{keywordcolor}{map} \textcolor{keywordcolor}{list} (\textcolor{keywordcolor}{list} \grqq x\grqq{} \grqq y\grqq{} \grqq z\grqq)))
        \item (\textcolor{keywordcolor}{map} \textcolor{keywordcolor}{list} (\textcolor{keywordcolor}{list}  \grqq a\grqq{}  \grqq b\grqq{}  \grqq c\grqq) (\textcolor{keywordcolor}{list} 1 2 3) (\textcolor{keywordcolor}{list} \textcolor{keywordcolor}{true} \textcolor{keywordcolor}{false} \textcolor{keywordcolor}{true}))
        \item (\textcolor{keywordcolor}{foldr} \textcolor{keywordcolor}{cons} (\textcolor{keywordcolor}{list} -10 -1) (\textcolor{keywordcolor}{list} 1 10 100 1000))
    \end{enumerate}

    \begin{solution}
        \begin{enumerate}
            \item (\textcolor{keywordcolor}{list} 5 7 9)
            \item (\textcolor{keywordcolor}{list} 1 3 4)
            \item 12
            \item (\textcolor{keywordcolor}{list} \grqq 3\grqq{} \grqq abc\grqq)
            \item (\textcolor{keywordcolor}{list} \grqq x\grqq)
            \item (\textcolor{keywordcolor}{list} (\textcolor{keywordcolor}{list} \grqq a\grqq{} 1 \textcolor{keywordcolor}{true}) (\textcolor{keywordcolor}{list} \grqq b\grqq{} 2)
                  \textcolor{keywordcolor}{false}) (\textcolor{keywordcolor}{list} \grqq c\grqq{} 3 \textcolor{keywordcolor}{true}))
            \item (\textcolor{keywordcolor}{list} 1 10 100 1000 -10 -1)
        \end{enumerate}
    \end{solution}
\end{task}

\clearpage

\begin{task}[credit = \stars{1}{3}]{Funktionen höherer Ordnung verwenden}
    Definieren Sie die folgenden Funktionen. Außerhalb der Funktionen \textcolor{keywordcolor}{map}, \textcolor{keywordcolor}{filter} und \textcolor{keywordcolor}{foldr} darf keine Rekursion verwendet werden.
    \begin{itemize}
        \item Eine Funktion \code{zip}, die aus zwei gleich langen Listen eine Liste von geordneten Paaren macht. Beispiel:
              \newline
              (\code{zip} (\textcolor{keywordcolor}{list} \grqq a\grqq{} \grqq b\grqq)(\textcolor{keywordcolor}{list} 1 2)) \(\rightarrow\) (\textcolor{keywordcolor}{list} (\textcolor{keywordcolor}{list} \grqq a\grqq{} 1)(\textcolor{keywordcolor}{list} \grqq b\grqq{} 2))
        \item Eine Funktion \code{vec-mult}, die zwei gleich lange Listen von Zahlen erhält und das Skalarprodukt, also die Summe der paarweisen Produkte berechnet. Beispiel:
              \newline
              (\code{vec-mult } (\textcolor{keywordcolor}{list} 1 2 3)(\textcolor{keywordcolor}{list} 4 5 6)) \(\rightarrow\) (+ (* 1 4)(* 2 5)(* 3 6)) \(\rightarrow\) 32
    \end{itemize}

    \begin{solution}
        \begin{itemize}
            \item \code{zip}
                  \lstinputlisting[style = Racket]{codes/V3_Part01_Solution.rkt}
            \item \code{vec-mult}
                  \lstinputlisting[style = Racket]{codes/V3_Part02_Solution.rkt}
        \end{itemize}
    \end{solution}
\end{task}

\clearpage

\begin{task}[credit = \stars{1}{3}]{Lambda-Ausdrücke}
    \lstinputlisting[style = Racket]{codes/V4_Task.rkt}
    Ergänzen Sie den Vertrag, sowohl für die Funktion \code{z}, als auch für den Lambda-Ausdruck. Was liefert \code{((z 3) 4)} zurück?

    \begin{solution}
        \lstinputlisting[style = Racket]{codes/V4_Solution.rkt}
    \end{solution}
    \begin{itemize}
        \item Das Ergebnis von \code{((z 3) 4)} ist 12.
    \end{itemize}
\end{task}

\begin{task}[credit = \stars{2}{3}]{Foo Reloaded I}
    \label{task:V5}
    Erinnern Sie sich noch an die Funktion \code{foo} aus Aufgabe V7 vom letzten Übungsblatt? Zur Erinnerung: Gegeben ist ein Struct-Typ \code{abc} mit zwei Feldern \code{a} und \code{b}. Die Funktion \code{foo} bekommt einen Parameter \code{p} und liefert falls \code{p} vom Typ \code{abc} und zudem der Wert im Feld \code{b} von \code{p} eine Liste ist eine Liste zurück, deren erstes Element der Wert von Feld \code{a} in \code{p} ist, und der Rest der zurückgelieferten Liste ist die Liste im Feld \code{b} von \code{p} (also eine Liste in der Liste). Andernfalls liefert \code{foo} einfach \textcolor{keywordcolor}{false} zurück.
    \br
    Definieren Sie nun eine Funktion \code{bar1}, die einen Parameter \code{lst} übergeben bekommt. Für jedes Element \code{x} in \code{lst}, das vom Typ \code{abc} ist, soll die Ergebnisliste von \code{bar1} das Ergebnis der Anwendung von \code{foo} auf \code{x} enthalten. Weitere Elemente darf die Ergebnisliste von \code{bar1} nicht enthalten.
    \br
    \textbf{Verbindliche Anforderung:} Sie dürfen in dieser Aufgabe noch keine Funktionen höherer Ordnung wie \textmd {keywordcolor}{map} oder \textcolor{keywordcolor}{filter} verwenden. Diese Funktionalitäten müssen von Ihnen selbst implementiert werden.

    \begin{solution}
        \lstinputlisting[style = Racket]{codes/V5_Solution.rkt}
    \end{solution}
\end{task}

\clearpage

\begin{task}[credit = \stars{2}{3}]{Foo Reloaded II}
    Definieren Sie nun eine Funktion \code{bar2}. Diese besitzt die gleiche Funktionalität wie \code{bar1} aus Aufgabe \hyperref[task:V5]{V5}. In dieser Aufgabe wird die Funktionalität allerdings nicht mehr selbstgeschrieben, sondern an die vordefinierten Funktionen \textcolor{keywordcolor}{map} und \textcolor{keywordcolor}{filter} delegiert. Nutzen Sie Lambda-Ausdrücke, welche Sie innerhalb der Aufrufe von \textcolor{keywordcolor}{map} und \textcolor{keywordcolor}{filter} definieren.

    \begin{solution}
        \lstinputlisting[style = Racket]{codes/V6_Solution.rkt}
    \end{solution}
\end{task}

\begin{task}[credit = \stars{2}{3}]{Kartesisches Produkt}
    Definieren Sie eine Funktion \code{cartesian-prod}, die zwei Zahlenlisten erhält und das \href{https://de.wikipedia.org/wiki/Kartesisches_Produkt}{kartesische Produkt} der beiden bildet. Beispiel:
    \newline
    (\code{cartesian-prod} (\textcolor{keywordcolor}{list} 1 2)(\textcolor{keywordcolor}{list} 3 4)) \(\rightarrow\) (\textcolor{keywordcolor}{list} (\textcolor{keywordcolor}{list} 1 3)(\textcolor{keywordcolor}{list} 1 4)(\textcolor{keywordcolor}{list} 2 3)(\textcolor{keywordcolor}{list} 2 4))

    \begin{solution}
        \lstinputlisting[style = Racket]{codes/V7_Solution.rkt}
    \end{solution}
\end{task}

\clearpage

\begin{task}[credit = \stars{3}{3}]{Bibliothek Leihgebühren}
    Eine Bibliothek verwaltet ihr Leihsystem nun in Racket. Dazu wird ein neuer Struct-Typ \code{br} definiert.
    \lstinputlisting[style = Racket]{codes/V8_Task.rkt}
    Das Feld \code{id} ist dabei ein String und stellt die ID-Nummer des ausgeliehenen Buches dar. Das Feld \code{pop} ist eine Zahl zwischen 1 bis 6 und gibt die Beliebtheit des Buches an (je größer die Zahl, desto beliebter das Buch). Das letzte Feld \code{type} ist wieder ein String, der entweder \grqq Single\grqq{} oder \grqq Subscription\grqq{} sein kann, je nachdem, ob es sich um eine einmalige Ausleihe oder einen Abonnenten handelt.
    \br
    Folgende Regeln gelten in der Bibliothek: Abonnenten zahlen für jedes ausgeliehene Buch pauschal 1,50€. Bei normalen Kunden berechnet sich der Preis über die Beliebtheit des Buches. Pro Beliebtheitsstufe kostet das Buch 1,75€. Somit kostet ein Buch mit Beliebtheitsstufe 3 beispielsweise 5,25€.
    \br
    Ihre Aufgabe ist es nun eine Funktion \code{fee-total} zu definieren. Diese enthält eine Liste von \code{br}-Structs (die Ausleihliste) und gibt die Gesamteinnahmen aus eben dieser Ausleihliste zurück.

    \begin{solution}
        \lstinputlisting[style = Racket]{codes/V8_Solution.rkt}
    \end{solution}
\end{task}

\clearpage

\begin{task}[credit = \stars{3}{3}]{Wer bekommt die Zulassung?}
    Schreiben Sie eine Prozedur zur Prüfung der Zuteilung einer Studienleistung im Modul X. Dort sind 50 Hausaufgaben-, 35 Zwischenklausur- und 50 Projektpunkte sowie insgesamt mindestens 180 Punkte aus den drei Bereichen zusammen erforderlich. Definieren Sie dazu eine Funktion \code{passed} mit folgender Signatur
    \br
    (\textcolor{keywordcolor}{list} of \textcolor{keywordcolor}{number})(\textcolor{keywordcolor}{list} of (\textcolor{keywordcolor}{list} of \textcolor{keywordcolor}{number} \textcolor{keywordcolor}{number} \textcolor{keywordcolor}{number})) \(\rightarrow\) (\textcolor{keywordcolor}{list} of \textcolor{keywordcolor}{number})
    \br
    Diese Funktion erhält aus Datenschutzgründen separat die Liste der Matrikelnummern sowie eine Liste von Listen mit Punkten für Hausaufgaben, Zwischenklausur und Projekt (in dieser Reihenfolge). Die Precondition ist dabei, dass die Listen gleich lang sind und dass die Matrikelnummer an Position \code{i} der ersten Liste zu den Punkten an Position \code{i} der zweiten Liste gehört (vergessen Sie die Precondition nicht im Vertrag der Funktion). Die Ergebnisliste enthält die Matrikelnummern aller Studierenden, die die Bedingungen für die Studienleistung erfüllt haben. Die Reihenfolge der Studierenden soll dabei erhalten bleiben.

    \begin{solution}
        \lstinputlisting[style = Racket]{codes/V9_Solution.rkt}
    \end{solution}
\end{task}

\clearpage

\begin{task}[credit = \stars{3}{3}]{Bildverarbeitung in Racket}
    Um diese Aufgaben in DrRacket ausführen zu können, setzen Sie bitte \code{(require 2htdp/image)} in die oberste Zeile Ihrer Datei ein.
    \br
    Bilder bestehen aus vielen aufeinanderfolgenden Pixeln. Jedes Pixel nimmt dabei genau die Farbe an, die durch sein sogenanntes RGB-Tripel beschrieben werden. Dies ist durch die Darstellung im sogenannten \href{https://de.wikipedia.org/wiki/RGB-Farbraum}{RGB-Farbraum}, ein sogenannter technischer Farbraum, der die Farbwahrnehmung durch das additive Mischen der drei Grundfarben nachbildet, begründet. Jede Farbe lässt sich dabei durch ein Tripel \textit{(R, G, B)} darstellen, wobei die drei Zahlen jeweils den Anteil der jeweiligen Grundfarbe angeben. So ist das klassische rot durch \((255,0,0)\), gelb als Mischung zweier Grundfarben durch \((255,255,0)\) und braun als Mischung aller Grundfarben als \((153,102,51)\) dargestellt.
    \br
    Der Einfachheit wegen benutzen wir nur Bilder im PNG-Format (d.h. Dateiendung \code{.png}), die keine transparenten Farben enthalten,  also keinen Alphakanal besitzen. Ein Bild ist in Racket immer ein Struct vom Typ \code{image}. Jedes Bild besteht aus seinen aufeinanderfolgenden Pixeln. In Racket ist ein Pixel als \code{color}-Struct definiert:
    \lstinputlisting[style = Racket]{codes/V10_Task.rkt}
    Die ersten drei Felder sind das Tripel des RGB-Farbraums und liegen zwischen \(0\) und \(255\). Den Alpha-Wert (Siehe Transparenz, Kapitel 02 der Vorlesung) ignorieren wir in dieser Übung, er soll immer auf \(255\) gesetzt werden. Folgende Funktionen gibt es bereits für die Bildverarbeitung in Racket:
    \begin{itemize}
        \item Um aus einem \code{image} die entsprechenden \code{color}-Structs zu bekommen, gibt es die Funktion
              \newline
              \code{(image->color-list img)}.
              \newline
              Diese gibt eine Liste von \code{color}-Structs für das übergebene Bild zurück.
        \item Um aus einer Liste von \code{color}-Structs ein Bild zu generieren gibt es die Funktion \code{(color-list->bitmap clr-lst width height)}. Diese benötigt neben der Liste von \code{color}-Structs auch die Breite und Höhe des zu generierenden Bildes (über die Funktionen \code{(image-width img)} und \code{(image-height img)} abrufbar).
        \item Mit \code{(bitmap/file \grqq image.png\grqq)} laden Sie das Bild im PNG-Format namens \grqq image\grqq , welches im gleichen Verzeichnis wie die \code{.rkt} Datei liegt. Mittels \code{(save-image img \grqq out.png\grqq)} speichern Sie ein \code{image}-Struct unter dem Namen \grqq out\grqq{} dort.
    \end{itemize}
    Nutzen Sie für die folgenden beiden Aufgaben Funktionen höherer Ordnung!
    \begin{enumerate}
        \item Definieren Sie eine Funktion \code{(count-black-white img)}. Diese bekommt ein Bild übergeben, welches nur aus schwarzen \((0,0,0)\) und weißen Pixeln \((255,255,255)\) besteht. Zurückgegeben werden soll eine zweielementige Liste, welche an erster Position die Anzahl an schwarzen und an zweiter Position die Anzahl an weißen Pixeln enthält.
        \item Definieren Sie eine Funktion \code{(negative-transformation img)}. Diese bekommt ein Bild als \code{image}-Struct übergeben und gibt die Negativtransformation dieses Bildes zurück. Dazu berechnen Sie die RGB-Werte für jeden Pixel neu über den folgenden Zusammenhang: \((R_{\text{neg}}, G_{\text{neg}}, B_{\text{neg}}) = (255 - R, 255 - G, 255 - B)\)
    \end{enumerate}

    \clearpage

    \begin{solution}
        \begin{enumerate}
            \item\hfill
                  \lstinputlisting[style = Racket]{codes/V10_Part01_Solution.rkt}
            \item\hfill
                  \lstinputlisting[style = Racket]{codes/V10_Part02_Solution.rkt}
        \end{enumerate}
    \end{solution}
\end{task}
\end{document}
